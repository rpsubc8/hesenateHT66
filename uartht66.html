<!DOCTYPE html>
<!-- Code by ackerman -->
<html lang="es">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UART HESENATE HT66</title>
 </head>
 <body>
  Only Google Chrome, Microsoft Edge, Opera<br>
  It is recommended to reload the page each time a read or write action is performed, in order to free up the UART port.
  <table>
   <tbody>
    <tr><th></th><td></td></tr> 
    <tr>
	 <td>
	  <button type='button' id="btnDUMP" onclick="ExecDUMP()">DUMP</button>
	  <label name="lblDumpProgress" id="lblDumpProgress">Progress:</label>
	 </td>
    </tr> 
	<tr>
	 <td>
	  <button type='button' id="btnSendRadio" onclick="ExecSendMemRadio();">Send Radio</button>
	  <label name="lblSendOptions"><input type="checkbox" id="chkOptions" checked> Options </label>
	  <label name="lblSendChannels"><input type="checkbox" id="chkChannels" checked> Channels </label>
	 </td>
	</tr>
	<tr>
     <td><button type='button' id="btnSaveFile" onclick="ExecSaveDat();">Save</button></td>
	</tr>
    <tr>
     <td>
	  <button type='button' id="btnLoadFile" onclick="ExecLoadDat();">Load</button>	  
      <input type='file' id='fileinput'>
	 </td>
	</tr>   
    <tr>
     <th>OUTPUT</th>
	 <th>LOG</th>
     <td></td><td></td>
    </tr>	  
    <tr>	 
     <td><textarea id="txtareaOut" name="txtareaOut" rows="20" cols="54" readonly></textarea></td>
	 <td><textarea id="txtareaLog" name="txtareaLog" rows="20" cols="54" readonly></textarea></td>
    </tr>
	<tr>
	 <td><button type="button" onclick="window.location.href='index.html';">Back Frequencies web</button>
	</tr>
   </tbody>
  </table>
 
  <script>
   var port= null;
   var gb_error=0;
   var gb_warn=0;
   var gb_log="";
   var gb_out="";
   var gb_receiv= new Array(2048).fill(0);
   var topeReceived= 2048;
   var gb_receiv_cont=0;
   var gb_do_wall=1;
   var gb_do_wch=0;
   var gb_do_wopt=0;
   //var dataSendTX= new Array(20).fill(0);
   var dataSendTXtmp = Array.from(
    { length: 20 },
    () => new Uint8Array(64).fill(0)
   );
   var dataSendTX = Array.from(
    { length: 20 },
    () => new Uint8Array(17).fill(0)
   );      
   var dataSendFile= new Array(1024).fill(' ');
   var gb_contDataSendFile=0;
   var cHex= ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'];

   
   //HANDSHAKE BEGIN
   const trama0= new Uint8Array([0x02,0x54,0x39,0x39,0x39,0x52,0x41,0x4D]); //T999RAM
   const trama1= new Uint8Array([0x02]);
   const trama2= new Uint8Array([0x06]);
   const trama3= new Uint8Array([0x05]);
   const trama4= new Uint8Array([0x06]);
   //HANDSHAKE END
   //GET CHANNEL BEGIN
   const trama5= new Uint8Array([0x52,0x00,0x00,0x0D]);
   //GET CHANNEL END
   
   var gb_writer;
   var gb_reader;
   
   var TIMEOUT= 100;   // Timeout (100 ms)
   var TIMETXDELAY= 200;
   var TIMETXDELAYCH= 1000;
   var TIMEINIT= 1000;
   var TIMETXRXDELAY= 200;
   
   
   function delay(ms)
   {    
     return new Promise(resolve => setTimeout(resolve, ms));
   }
   
   function ImprimeHex(data)
   {
    var aReturn="";
	
    try
    {	
     var tot= data.length;	 
	
     for (var i=0;i<tot;i++)
	 {
      aReturn+=data[i].toString(16).toUpperCase().padStart(2, '0');
	 }
	 //console.log(cadLog);	 	 
	}
	catch (error) 
	{
     console.error(error);
    }	
	
	return aReturn;
   }

   
   function ProgressBarDump(aText, aCur, aTot)
   {
    try
	{
     document.getElementById("lblDumpProgress").textContent = aText+": "+aCur.toString()+"/"+aTot.toString();
	}
	catch (error) 
	{
     console.error(error);
    }	
   }
   
   function ShowOut()
   {
    try
	{
     var contLine=0;
	 var cad="";
	
     gb_log+= "\n\n";
     gb_log+="Total:"+gb_receiv_cont+"\n";
 
     cad= "[M31_Analog_Redio]\r\n";
	 gb_log+= cad;
	 gb_out+= cad;
 
     for (var i=0; i<gb_receiv_cont;i++)
     {
	  cad= gb_receiv[i].toString(16).toUpperCase().padStart(2, '0') +" ";
      gb_log+= cad;
	  gb_out+= cad;
  
      contLine++;
      if(contLine>=17)
      {
	   cad= "\r\n";
       gb_log+= cad;
	   gb_out+= cad;
       contLine=0;
      }
     }
	 
	 gb_log+= "Dump bytes:"+ gb_out.length.toString() +"\n";
	}
	catch (error) 
	{
     console.error(error);
    }		 
   }
    

   async function SendHandshake()
   {
    var cad="";
	
    try
	{
	 cad= "HANDSHAKE BEGIN";
	 console.log(cad);	gb_log+= cad+"\n";
	
	 await enviarTrama(trama0);
	 await delay(TIMETXRXDELAY);
	 
	 gb_receiv_cont=0;
	 ProgressBarDump("HANDSHAKE",1,5);
	 cad= "TX:"+ImprimeHex(trama0);
	 console.log(cad);	gb_log+= cad+"\n";
	 const respuesta0= await receiveData(0x06);
	 cad= "RX("+ respuesta0.length.toString()+"):"+ ImprimeHex(respuesta0);
	 console.log(cad); gb_log+= cad+"\n"; //console.log("Respuesta 0:", respuesta0);	 
	 await delay(TIMETXDELAYCH);

     gb_receiv_cont=0;
     ProgressBarDump("HANDSHAKE",2,5);
	 await enviarTrama(trama1);
	 await delay(TIMETXRXDELAY);
	 cad="TX:"+ImprimeHex(trama1);
	 console.log(cad); gb_log+= cad+"\n";
	 const respuesta1= await receiveData(0x06);
	 cad= "RX("+ respuesta1.length.toString()+"):"+ ImprimeHex(respuesta1);
	 console.log(cad); gb_log+= cad+"\n"; //console.log("Respuesta 0:", respuesta0); //console.log("Respuesta 1:", respuesta1);	 ;
	 await delay(TIMETXDELAYCH);

     gb_receiv_cont=0;
     ProgressBarDump("HANDSHAKE",3,5);
	 await enviarTrama(trama2);
	 await delay(TIMETXRXDELAY);
	 cad= "TX:"+ImprimeHex(trama2);
	 console.log(cad); gb_log+= cad+"\n";
	 const respuesta2= await receiveData(0x06);
	 cad= "RX("+ respuesta2.length.toString()+"):"+ ImprimeHex(respuesta2);
	 console.log(cad); gb_log+= cad+"\n"; //console.log("Respuesta 0:", respuesta0); //console.log("Respuesta 2:", respuesta2);	 
	 await delay(TIMETXDELAYCH);
	
	 gb_receiv_cont=0;
	 ProgressBarDump("HANDSHAKE",4,5);
	 await enviarTrama(trama3);
	 await delay(TIMETXRXDELAY);
	 cad="TX:"+ImprimeHex(trama3);
	 console.log(cad); gb_log+= cad+"\n";
	 const respuesta3= await receiveData(0xFF);
	 cad= "RX("+ respuesta3.length.toString()+"):"+ ImprimeHex(respuesta3);
	 console.log(cad); gb_log+= cad+"\n"; //console.log("Respuesta 0:", respuesta0); //console.log("Respuesta 3:", respuesta3);	 
	 await delay(TIMETXDELAYCH);
	
	 gb_receiv_cont=0;
	 ProgressBarDump("HANDSHAKE",5,5);
	 await enviarTrama(trama4);
	 await delay(TIMETXRXDELAY);
	 cad= "TX:"+ImprimeHex(trama4);
	 console.log(cad); gb_log+= cad+"\n";
	 const respuesta4= await receiveData(0x06);		
	 cad="RX("+ respuesta4.length.toString()+"):"+ ImprimeHex(respuesta4);
	 console.log(cad); gb_log+=cad+"\n"; //console.log("Respuesta 0:", respuesta0); //console.log("Respuesta 4:", respuesta4);	 
	 await delay(TIMETXDELAYCH);   
	 
	 cad= "HANDSHAKE END";
	 console.log(cad);	gb_log+= cad+"\n";	 
	}
	catch (error) 
	{
     console.error(error);
    }
   }
   
   async function DumpMemRadio()
   {    
	var cad="";
   
    try
	{
	 gb_receiv_cont=0;
	
     await SendHandshake();
	 
     gb_receiv_cont=0;
	 trama5[2]= 0x00;
     for (var i=0;i<18;i++)	
     {
	  ProgressBarDump("READ LINE",(i+1),18);
      await enviarTrama(trama5);
	  await delay(TIMETXRXDELAY);
	  cad= "TX "+(i+1).toString()+":"+ImprimeHex(trama5);
	  console.log(cad); gb_log+= cad+"\n";
      const respuesta5= await receiveData(0x57); //expected value 5700000D318DA802318DA802FFFFFFFFFF
	  cad= "RX("+ respuesta5.length.toString()+"):"+ ImprimeHex(respuesta5);
	  console.log(cad); gb_log+=cad+"\n";
	  
      trama5[2]+=0x0D; //Add channel
	  await delay(TIMETXDELAYCH);
     }	 	
	}
	catch (error) 
	{
     console.error(error);
    }
   }

   async function conectar()
   {
    try
	{
	 gb_error=0;
	 gb_warn=0;
	
	 if (port==null)
	 {
      port = await navigator.serial.requestPort(); // Solicita puerto al usuario  
	 }
     await port.open({ baudRate: 9600,dataBits: 8,stopBits: 1,parity: "none" }); //9600 baudios
     console.log("Port open OK"); gb_log+= "Port open OK\n";
	
	 gb_writer = await port.writable.getWriter();
     gb_reader = await port.readable.getReader();
		
	 //await DumpMemRadio();
	 
	 //await Desconectar();	 
	}
	catch (error) 
	{
     console.error(error);
    }	
   }
         

   async function Desconectar()
   { 
    try
	{
	 var cad="";
	 
	 try
	 {	  
      if ((port)&&(gb_reader))
	  {	          
	   await gb_reader.cancel();
	   await gb_reader.releaseLock();
	  }
	 }
	 catch(errorReader)
	 {
      console.error(errorReader);	 
	 }
	 
	 try
	 {
	  if ((port)&&(gb_writer))
	  {	   	   	   
	   await gb_writer.releaseLock();
	  }
	 }
	 catch(errorWriter)
	 {
      console.error(errorWriter);	 
	 }	 
	 	 
	 try
     {	 
	  if (port)
	  {	          
       await port.close();
	   //await port.forget();
	   port= null
       gb_writer= null;
	   gb_reader= null;
	  }
	 }
	 catch(errorPort)
	 {
      console.error(errorPort);	 
	 }	 
     
	 cad= "Port close OK";
	 console.log(cad); gb_log+=cad+"\n";	      
	}
	catch (error) 
	{
     console.error(error);
    }	
   }   
   
   async function enviarTrama(datosArray)
   {
   /*
    const writer = port.writable.getWriter();  
    // Ejemplo de trama: [Inicio(0x02), ...datos, Fin(0x03)]
    //const trama = new Uint8Array([0x02,0x54,0x39,0x39,0x39,0x52,0x41,0x4D]);
	const trama = datosArray;
  
    await writer.write(trama);
    writer.releaseLock(); // Libera el escritor para otros procesos
    console.log("Trama enviada:", trama);
	*/
	try
	{	
	 await gb_writer.write(datosArray);
	}
    catch (error) 
	{
     console.error(error);
    }
   }
  
  
   function procesarTrama(bytes)
   {
    // Aquí implementas la lógica para reconstruir tu trama
    //console.log("Bytes recibidos:", bytes);
	try
	{
	 console.log("Byte("+ bytes.length.toString()+"): " +bytes[0].toString());
	}
	catch (error) 
	{
     console.error(error);
    }	
   }
  
   async function receiveData(expectedValue)
   {
   /*
    const timeoutMs = 2000;
	const start = Date.now();
	let buffer = [];
   
    //while (port.readable)
	while (true)
	{
//     const reader = port.readable.getReader();
     try {
      while (true) 
	  {
        //const { value, done } = await reader.read();
		const { value, done } = await gb_reader.read();
        if (done) break; // Puerto cerrado
        
        // 'value' es un Uint8Array con los bytes recibidos
        procesarTrama(value);
		
		return new Uint8Array(buffer);
      }
     } 
	 catch (error) 
	 {
       console.error("Error leyendo:", error);
     } 
	 finally 
	 {
       //reader.releaseLock();
	   gb_reader.releaseLock();
     }
    }
*/
    try
    {
     const timeoutMs = 1000;
     const start = Date.now();
     let buffer = [];
	 var cad="";

     while (true) 
	 {
      const { value, done } = await gb_reader.read();
      if (done) break;

      if (value) 
	  {
       buffer.push(...value);
      
	   if (buffer.length>0)
	   {
        
		for (var i=0;i<buffer.length;i++)
		{
		 if (gb_receiv_cont<topeReceived)
         {
          gb_receiv[gb_receiv_cont]= buffer[i];
          gb_receiv_cont++;
         }	   
		}
		
        if (buffer[0]!=expectedValue)
        {
         gb_warn=1;
		 cad= "WARN!!! expected value "+ImprimeHex(expectedValue);
         console.log(cad); gb_log+= cad+"\n"; 
        }	
	   }
       return new Uint8Array(buffer);
      }

      if (Date.now() - start > timeoutMs) 
	  {
       throw new Error("Timeout esperando respuesta");
      }
     }
	}
	catch (error) 
	{
     console.error(error);
    }		
   }
  
   function ImprimeLog()
   {
    try
    {
     document.getElementById("txtareaLog").innerHTML = gb_log;
    }
    catch (error)	
	{
	 console.error(error);
	}
   }
   
   function ImprimeOut()
   {
    try
    {
     document.getElementById("txtareaOut").innerHTML = gb_out;
    }
    catch (error)	
	{
	 console.error(error);
	}
   }   
  
   async function ExecDUMP()
   {
    try
    {    
     gb_log="";
	 gb_out="";

	 ImprimeLog();
	 ImprimeOut();
	 
	 console.log("UART init"); gb_log+= "UART init\n";
	 await Desconectar();
	 await conectar();
	 
	 await DumpMemRadio();
	 
	 await Desconectar();
	 
	 ShowOut();
	 ImprimeLog();
	 ImprimeOut();
	 
	 if (gb_out.length<974)
	 {	
      alert('Error!!! The file dump is less than 974 bytes.');
	 }	 
	 
	 
	 //console.log("UART conect");	 
	 //enviarTrama();
	 //Desconectar();
	 //console.log("UART disconect");
	 
	}
    catch (error)
    {
     console.error(error);
    }   
   }
   
   function GetIdHex(c)
   {
    var aReturn=0;
 
    try
	{
     for (var i=0;i<16;i++)
     {
      if (cHex[i]==c)
      {
       aReturn= i;
       break;
      }
     }
	}
    catch (error)
    {
     console.error(error);
    }   	
 
    return aReturn;
   }
   
   function jj_strlen(cad)
   {
    var aReturn=0;
	
	for (var i=0;i<64;i++)
	{
     if (cad[i]=='\0')
	 {
	  aReturn= i;
	  break;
	 }
	}	
	
	return aReturn;
   }
   
   
   async function PrepareSendBytes()
   {
    try
    {
     var contRead=0;
     var contWrite=0;
     var carHex=' ';
     var highByte=0;
     var lowByte=0;
     var auxByte=0;
     var tot=0;
     //var cad="PrepareSendBytes BEGIN";
     
     //console.log(cad); gb_log+= cad+"\n";
     for (var canal=0;canal<18;canal++)
     {
      contRead=0;
      contWrite=0;  
      tot= 34; //jj_strlen(dataSendTX[canal]); //dataSendTX[canal].length;
	  //cad= "tot:"+tot.toString();
	  //console.log(cad); gb_log+= cad+"\n";
	  
      while (contRead<tot)
      {
       carHex= dataSendTXtmp[canal][contRead];
       highByte= carHex; //highByte= GetIdHex(carHex);
       contRead++;
       
	   //cad= "(H-"+carHex+","+highByte+")";
	   //console.log(cad); gb_log+= cad+"\n";	   
	   
       carHex= dataSendTXtmp[canal][contRead];
       lowByte= carHex;  //lowByte= GetIdHex(carHex);  
       contRead++;
	   
	   //cad= "(L-"+carHex+","+lowByte+")";
	   //console.log(cad); gb_log+= cad+"\n";	   	   
  
       auxByte= (highByte<<4)|lowByte;
       dataSendTX[canal][contWrite]= auxByte;
       //dataSendTX[canal][(contWrite+1)]=0;
       contWrite++;
      }
	  
	  //cad="";
	  //for (var k=0;k<17;k++)
	  //{
	  // cad+= dataSendTX[canal][k].toString()+",";
	  //}
	  //console.log(cad); gb_log+= cad+"\n";
	  
     }	
	 
	 //cad="PrepareSendBytes END";
	 //console.log(cad); gb_log+= cad+"\n";
	}
    catch (error)
    {
     console.error(error);
    }   		
   }
   
   async function ShowSendFile()
   {
    try
	{
     var contLine=0;
     var canal=0;
	 var cad="ShowSendFile BEGIN";
	 
	 console.log(cad); gb_log+= cad+"\n";
 
     for (var i=0;i<gb_contDataSendFile;i++)
     {
      gb_log+= dataSendFile[i]; //printf("%c",dataSendFile[i]);
      dataSendTXtmp[canal][contLine]= GetIdHex(dataSendFile[i]); //dataSendTX[canal][contLine]= dataSendFile[i];
      //dataSendTX[canal][(contLine+1)]='\0';
	  //cad="tope:"+contLine.toString();
	  //console.log(cad); gb_log+= cad+"\n";
  
      contLine++;
      if (contLine>=34)
      {//17x2
       gb_log+="\n"; //printf("\n");
       contLine=0;  
       canal++;
      }
     }
	 
	 cad= "ShowSendFile END";
	 console.log(cad); gb_log+= cad+"\n";
	}
    catch (error)
    {
     console.error(error);
    }
   }
   
   async function LoadSendFile()
   {
    try
	{
	 //gb_log+= "LoadSendFile\n";
	 
     var c=' ';
     var cntLine=0;
     var sizeFile= gb_out.length;
	 
	 gb_log+= "Size:"+sizeFile.toString()+"\n";
      
     gb_contDataSendFile=0;
	 
	 for (var j=0;j<sizeFile;j++)
	 {
	  c= gb_out[j];
	  
	  if (c=='\n')
      {                 
       cntLine++; 
       //printf("\n"); 
       gb_log+="\n";
      }
      else
      {
       if (cntLine>0)
       {
        for (var i=0;i<16;i++)
        {
         if (c==cHex[i])
         {
          gb_log+= c; //printf("%c",c);
          dataSendFile[gb_contDataSendFile]= c;
          gb_contDataSendFile++;
		  break;
         }
        }		
       }
      }	  
	 }
	}
    catch (error)
    {
     console.error(error);
    }	
   }
   
   async function SendMemRadio()
   {
    try
    {
	 var cad="";
	 var totBar= 18;
	 var contBar=1;
	 
	 if (gb_do_wall==1){ totBar= 18; }
	 else{ totBar= (gb_do_wch==1)? 16: 2; }
	 
	 await LoadSendFile()
	 await ShowSendFile();
	 await PrepareSendBytes();
	 
	 //await ShowDataSendTX();
	 await SendHandshake();
	 
	 gb_receiv_cont=0;
     for (var i=0;i<18;i++)
     {	  	 
      if (gb_do_wall==1)
      {
      }
      else
      {
       if (
           ((gb_do_wch==1)&&(i>=16)&&(i<18))
           ||
           ((gb_do_wopt==1)&&(i>=0)&&(i<16))
          )
       {//only send channel, skip options
        continue;
       }
      }
	  
	  ProgressBarDump("SEND LINE",contBar,totBar);
	  contBar++;

      await enviarTrama(dataSendTX[i]);
      await delay(TIMETXRXDELAY);  
	  cad= "TX "+(i+1).toString()+"("+dataSendTX[i].length.toString()+"):"+ImprimeHex(dataSendTX[i]);
	  console.log(cad); gb_log+= cad+"\n";	  
	  
      const respuesta= await receiveData(0x06);  //expected value 06
	  cad= "RX("+ respuesta.length.toString()+"):"+ ImprimeHex(respuesta);
	  console.log(cad); gb_log+=cad+"\n";
	  
      await delay(TIMETXDELAYCH);
     }
	 
    }	
    catch (error)
    {
     console.error(error);
    }   	
   }
   
   async function ExecSendMemRadio()
   {
    try
    {    
     gb_log="";
	 
	 ImprimeLog();
	 
	 if (gb_out.length<974)
	 {	
      alert('Error!!! The file to send radio is less than 974 bytes.');
      return;	  
	 }	 
	 	 
	 console.log("UART init"); gb_log+= "UART init\n";
	 
	 GetParam();
	 
	 await Desconectar();
	 await conectar();	 
	 
	 await SendMemRadio();
	 
	 await Desconectar();
	 
	 ImprimeLog();	 
	}
    catch (error)
    {
     console.error(error);
    }     
   }
   
   
   
   //Save file data
   function ExecSaveDat()
   {
    try
    {
     const content = gb_out;
     const blob = new Blob([content], { type: 'text/plain' });
     const url = URL.createObjectURL(blob);
     const a = document.createElement('a');
	
	 if (gb_out.length<974)
	 {	
      alert('Error!!! The file to be generated is less than 974 bytes. It will not be saved.');
	 }
	 else
	 {
      a.href = url;
      a.download = 'custom.dat';  // Set the default filename
      document.body.appendChild(a);
      a.click();  // Trigger the download
      document.body.removeChild(a);
      URL.revokeObjectURL(url);  // Clean up	  
	 }
	}
    catch (error)
    {
     console.error(error);
    }	 
   }
   
   
   
   function LoadFromData(cadData)
   {   	
	try
	{
	 if (cadData.length<974)
	 {
	  alert('Error!!! The file to be read is less than 974 bytes. It will not be read.');
	  return;
	 }
	 
	 gb_out= cadData;
	 
	 gb_log= "";
	 gb_log+= "Load file\n";
	 
	 ImprimeOut();
	 ImprimeLog();
    }
    catch (error)
    {
     console.error(error);
    }	 	
   }
   
   
   
   function uploadLocalFile(nameFile)
   {
    var input, file, fr;
	
    try    
	{
     file = nameFile || "";
 	    
     if (typeof window.FileReader !== 'function') 
     {
      console.log("The file API isn't supported on this browser.");
      return;
     };
	    
     input = document.getElementById('fileinput');
		
     if (file == "") 
     {
      if (!input) 
      {
       console.log("Couldn't find the fileinput element.");
       return;
      }
      else if (!input.files) {
				console.log("This browser doesn't seem to support the 'files' property of file inputs.");
				return;
			}
			else if (!input.files[0]) {
				console.log("Please select a file before clicking 'Load'");
				return;
			}
			else {
				file = input.files[0];
			};
			  					
			fr = new FileReader();
			fr.onload = receivedLocalBinary;
			fr.readAsBinaryString(file);
			
		} else {
		};

		

        function receivedLocalBinary()
		{            		
	  	 //alert(fr.result);	         		
		 LoadFromData(fr.result);
        }
	 }
	 catch (error)
     {
      console.error(error);
     }
    }
   
   
   function ExecLoadDat()
   {
    try
    {	
     uploadLocalFile();
    }
	catch (error)
    {
     console.error(error);
    }
   }
   
   function GetParam()
   {
    try
    {	 	 
	 var cad="";
	 
	 gb_do_wopt= (document.getElementById("chkOptions").checked) ? 1:0;
	 gb_do_wch= (document.getElementById("chkChannels").checked) ? 1:0;
	 gb_do_wall= ((gb_do_wopt===1)&&(gb_do_wch===1)) ? 1:0;
	 
	 if (gb_do_wall===1)
	 {
	  gb_do_wch= gb_do_wopt= 0;
	 }
	 
	 gb_log+= "Param: ";
	 gb_log+= (gb_do_wall===1) ? "all (channels options)":"";
     gb_log+= (gb_do_wch===1) ? "channels ":"";
     gb_log+= (gb_do_wopt===1) ? "options":"";
	 gb_log+= "\n";
	 
	 cad="Param: all("+gb_do_wall.toString()+") channels("+ gb_do_wch.toString()+") options("+gb_do_wopt.toString()+")";
	 console.log(cad); gb_log+=cad+"\n";
    }
	catch (error)
    {
     console.error(error);
    }    
   }
   
  
   //Init
   function onLoadFunctions()
   {
    try
    {	 
	}
    catch (error)
    {
     console.error(error);
    }
   }
  
  
   window.onload = onLoadFunctions;
  </script>
 </body>
</html> 